---
layout: post
title: 반정규화 (De-Normalization)
author: admin
date: 2023-08-25 07:10:00 +900
lastmod: 2023-08-25 07:10:00 +900
sitemap:
  changefreq: monthly
  priority: 0.5
categories: [DATABASE(DB), SQLD]  # 대문자로 작성
tags: [sql, sqld, de-normalization] # 소문자로 작성
---


> 해당 포스트는 `SQLD`를 학습하며 정리한 내용에 대한 포스트입니다.<br />
{:.prompt-info}

<br />

> 이론을 학습한 내용을 정리하고 퀴즈, 기출문제 등을 기록하려고 합니다.<br />
{:.prompt-tip}

<br />

# **🌈 반정규화 (De-Normalization)**

- **<span style="color:tomato">데이터베이스의 성능 향상을 위하여, `데이터 중복을 허용`하거나 그룹핑하여 `JOIN을 줄이는 데이터베이스 성능 향상 방법`</span>**

- **<span style="color:tomato">반정규화는 `조회(SELECT)속도는 향상`시키지만, `데이터 모델의 유연성은 낮아진다.`</span>**

> **주의해야할 점**
> 
> 조회 성능을 향상될 수 있으나, 입력, 수정, 삭제 성능은 저하될 수 있으며 데이터 정합성 이슈가 발생할 수 있다는 점이다.
> 
> 반정규화는 정규화가 수행되고 난 뒤, `반드시 해야하는 것은 아니며` 수행속도가 느려지는 등 `문제가 발생할 시에 고려`해볼 사항이다.<br/>
{:.prompt-warning} 

- 반정규화의 과정은 정규화가 끝난 후 거치게 되며 정규화와 마찬가지로 일정한 룰이 존재한다. 

## **💻 반정규화를 수행하는 경우**

- 정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우

- 다량의 범위를 자주 처리해야 하는 경우

- 특정 범위의 데이터만 자주 처리하는 경우

- 요약/집계 정보가 자주 요구되는 경우

- ###  **반정규화 절차**

| 단계 | 설명 |
| :---: | :--- |
| 대상 조사 및 검토 | - 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다. |
| 다른 방법 검토 | - 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다. <br/> - 예를 들어 클러스터링, 뷰, 인덱스 튜닝, 응용 프로그램, 파티션 등을 검토한다. |
| 반정규화 수행 | 테이블, 속성, 관계 등을 반정규화 한다. |
| 검증 및 모니터링 | 변경된 스키마가 실제로 성능 향상에 도움이 되었는지 확인하고 지속적으로 모니터링한다. |

<br/>

> **<span style="color:tomato">클러스터링</span>**
> 
> - 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때 **`물리적으로 정렬해서 저장하는 방법`**이다.
> 
> - 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.<br/>
{:.prompt-info}

<br />

## **💻 계산된 컬럼 추가**

- 배치 프로그램으로 총판매액, 평균잔고, 계좌평가 등을 미리 계산하고 그 결과를 특정 컬럼에 추가한다.<br/>
  ![계산된 컬럼 추가 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/6b56b1cb-2d37-4251-b133-51441aae61d6)

## **💻 테이블 반정규화**  

|||
|:-:|:-|
|테이블 병합|- 1:1 관계 테이블 병합 <br/> - 1:M 관계 테이블 병합 <br/> - 슈퍼 서브 타입 테이블 병합|
|테이블 분할|- 테이블 수직 분할(속성분할) <br/> - 테이블 수평 분할(인스턴스 분할, 파티셔닝)|
|테이블 추가|- 중복 테이블 추가 <br/>- 통계 테이블 추가 <br/> - 이력 테이블 추가 <br/> - 부분 테이블 추가 |

<br/>

### **🔍 테이블 병합** 

- 1대1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
- 업무 프로세스상 JOIN이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리할 경우 고려한다. 

- 1:M 관계 테이블 병합의 경우 1쪽에 해당하는 엔터티의 속성 개수가 많으면 병합했을 경우 중복 데이터가 많아지므로 테이블 병합에 적절하지 못하다. 

<br/>

![테이블 병합 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/420018d7-0002-4fbc-8742-6ca067ee603c){: width="500" height="500" }  

<br/>

- 1대N 관계의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.

- 슈퍼 타입과 서브 타입의 관계가 발생하면 테이블을  통합하여 성능을 향상시킨다.

>**Super type과 Sub type**
>
> - 고객 엔터티는 개인고객과 법인고객으로 분류된다. 이 때 `고객` 엔터티는 `슈퍼` 타입이고 `개인고객`과 `법인고객`은 `서브`타입이 된다.
> 
> - 즉, **`부모`**와 **`자식`** 간의 관계가 나타난다.
> 
> - 슈퍼 타입과 서브 타임의 관계는 **`배타적 관계`**와 **`포괄적 관계`**가 있는데, **`배타적 관계`**는 고객이 개인고객**`이거나`** 법인고객인 경우를 의미한다. **`포괄적 관계`**는 고객이 개인고객일 **`수도 있고`** 법인고객일 수도 있는 것이다.
> 
> ![Super type과 Sub type image](https://github.com/leekoby/leekoby.github.io/assets/118284808/605ccca7-dd31-4780-8a36-319cb4f23dfb)<br/>
{:.prompt-info}

#### **슈퍼 타입 및 서브타입 변환 방법**

| 변환 방법 | 설명 |
| :---: | :--- |
| OneToOne Type<br/>(1:1 타입) | - 슈퍼타입과 서브타입을 **`개별 테이블로 도출`**한다. <br/> - 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다. |
| Plus Type<br/>(슈퍼 + 서브타입) | - 슈퍼 타입과 서브 타입 테이블로 도출한다. <br/> - 조인이 발생하고 관리가 어렵다. |
| Single Type<br/>(All In One 타입) | - 슈퍼 타입과 서브 타입을 **`하나의 테이블로 도출`** 한다. <br/> - 조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁘다. |

<br />

### **🔍 테이블 분할**

**🪓 테이블 수직 분할**

- 엔터티의 일부 속성을 별도의 엔터티로 분할 

- 1:1 관계의 테이블이 2개 생긴다.

- 수직 분할은 컬럼을 분할하여 테이블을 만드는 것이다.

- 특정 테이블에서 컬럼 일부만 추출하는 경우 DISK I/O를 경감할 수 있는 방법이다.

![테이블 수직 분할 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/978e4681-7b94-4b03-91c8-2293c6531234){: width="500" height="500" } 

<br/>

**🪓 테이블 수평 분할**

- 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할 (파티셔닝)

![테이블 수평 분할 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/b471844a-5720-4471-ad0d-09611bd2d77c){: width="500" height="500" } 

<br/>

> **<span style="color:tomato">파티션 기법</span>**
> 
> - 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다.
> 
> - 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어 저장된다.
> 
> - **<span style="color:tomato">Range Partition</span>**: **`데이터 값의 범위를 기준으로 파티션을 수행`**한다.
> 
> - **<span style="color:tomato">List Partition</span>**: **`특정한 값을 지정하여 파티션을 수행`**한다.
> 
> - **<span style="color:tomato">Hash Partition</span>**: **`해시 함수를 적용하여 파티션을 수행`**한다.
> 
> - **<span style="color:tomato">Composite Partition</span>**: **`범위와 해시를 복합적으로 사용하여 파티션을 수행`**한다. <br/> **`2개 이상의 기법을 사용`**<br/> 
{:.prompt-info}


<br/>

> **<span style="color:tomato">해시 함수</span>**
> 
> 임의의 길이를 갖는 메세지를 입력 받아 고정된 길이의 해시 값을 출력하는 함수.
> 
> 암호 알고리즘에는 키가 사용되지만, 해시 함수는 키를 사용하지 않으므로 같은 입력에 대해서 항상 같은 출력이 나오게 된다. 
> 
> 이러한 <u>해시 함수를 사용하는 목적은 메세지의 오류나 변조를 탐지할 수 있는 <span style="color:#ff6600"><strong>무결성을 제공하기 위해 사용</strong></span>된다.</u>
{:.prompt-tip}

<br/>

> **<span style="color:tomato">파티션 테이블의 장점</span>**
> 
> - 데이터 조회 시에 액세스 범위가 줄어들기 때문에 성능이 향상된다.
>
> - 데이터가 분할되어 있기 때문에 I/O의 성능이 향상된다.
>
> - 각 파티션을 독립적으로 백업 및 복구가 가능하다.<br/>
{:.prompt-info}

<br/>

### **📌 테이블 추가**

**중복 테이블 추가** 

데이터의 중복을 감안하더라도 성능상 반드시 필요하다고 판단되는 경우 별도의 엔터티를 추가한다.

- **통계 테이블 추가** 

![통계 테이블 추가 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/8e9b20f2-90b8-482e-8a86-2bc5347013e4){: width="500" height="500" } 

<br/>

- **이력 테이블 추가** 

![이력 테이블 추가 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/bd1d41db-ccd0-4509-bb61-de4694649360){: width="500" height="500" } 

<br/> 

- **부분 테이블 추가**

![부분 테이블 추가 image](https://github.com/leekoby/leekoby.github.io/assets/118284808/76e5d53f-d495-4e5e-b82b-7d8c544c6676){: width="500" height="500" }

<br/>

## **💻 컬럼 반정규화**

- 중복 컬럼 추가 

    - 업무 프로세스상 JOIN이 필요한 경우가 많아 칼럼을 추가하는 것이 성능 측면에서 유리할 경우 고려

<br/>

- 파생 컬럼 추가 

    - 프로세스 수행 시 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식

    - 상품의 재고나 프로모션 적용 할인가 등이 여기에 해당 할 수 있다.
     
<br/>

- 이력 테이블 칼럼 추가

    - 대량의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가해 놓는 방식이다. 

    - 최신 데이터 여부 등이 해당할 수 있다.

## **💻 관계 반정규화 (중복관계 추가)**

- 업무 프로세스상 JOIN이 필요한 경우가 많아 중복 관계를 추가하는 것이 성능 측면에서 유리할 경우 고려한다. 

- 여러 경로를 거쳐 조인 할 수 있지만, 성능 저하를 예방하기 위해 추가적인 관계를 맺음

- 중복관계를 추가해줌으로써 데이터 무결성을 깨뜨리지 않을 수 있다.

<br/>

## 🎯 **기출 내용 추가**

### ❌ 하나의 테이블에 많은 칼럼을 추가하는 방법으로 반정규화를 수행하면 정규화된 모델보다 조회 속도는 항상 빨라진다. 그 이유는 조인이 없어지기 때문이다.

#### 👉 하나의 테이블에 컬럼의 수가 많아지면 조인의 수가 감소하는 것은 당연하다. 하지만, 하나의 테이블의 행의 길이가 길어져서 입출력을 하는데 있어서 **`Block Size`**가 커지기 떄문에 하나의 행을 조회할 때도 여러 번에 입출력이 발생하여 항상 속도가 빨라지는 것은 아니고 오히려 성능이 떨어진다. 

### ✅ 테이블의 반정규화 기법 중 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상시킬 수 있는 기법은?

#### 👉 [중복관계추가](#-관계-반정규화-중복관계-추가) 

무결성을 깨뜨지 않기 위해서는 중복성이 없어야 한다.


<br/>

# **📚 레퍼런스**

> 정미나. (유튜브 선생님에게 배우는) 유선배 SQL개발자(SQLD) 과외노트 / [정미나 저] (2023). Print.
{:.prompt-info }


> 한국데이터산업진흥원. SQL 자격검정 실전문제 : 국가공인 SQL전문가·국가공인 SQL개발자 / 한국데이터산업진흥원 [편] (2020). Print.
{:.prompt-info }

> [SQL 개발자 (SQLD) 자격증 따기 Part.1 / [유용한IT학습] ](https://www.inflearn.com/course/sqld-%EC%9E%90%EA%B2%A9%EC%A6%9D-%EC%B4%88%EA%B8%89-1/dashboard){:target="_blank"}
{:.prompt-info }